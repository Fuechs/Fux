package core;

get string;

io {

    :IOBuffer {
        intern buffer: str[256];
        
        operator[]<<(val: str) -> IOBuffer {
            list[] << val;
            flush();
            return self;
        }

        operator>>[](val: str) -> IOBuffer {
            val >> list[];
            flush();
            return self;
        }

        operator[](): str[] {
            return buffer;
        }

        operator[](index: u8): str {
            return buffer[index];
        }

        flush(): void {
            if (!buffer.full())
                return;

            for (obj: str in buffer)
                puts obj;
            buffer.clear();
        }
    }

    safe buffer: IOBuffer;

    put(args: var, ...): void {
        for (obj: var in args)
            buffer[] << (str) obj;
    }

    putln(args: var, ...): void {
        put(args);
        buffer[] << "\n";
        buffer.flush();
    }

    putf(data: str, args: var, ...): void {
        format(data, args);
        put(data);
    }

    getln(args: var, ...): str {
        put(args);
        buffer.flush();
        return __stdin__(0, '\n');
    }

    getch(args: var, ...): c8 {
        put(args);
        buffer.flush();
        return __stdin__(1);
    }

    clear(): void {
        buffer.flush();
        puts "\033[2J";
    }

    err(code: i64, args: var, ...): void {
        put(args);
        buffer.flush();
        if (code != 0)
            exit code;
    }
    
}