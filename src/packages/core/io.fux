package core;

get string;

io {

    :IOBuffer {
        ::() {
            intern self.buffer: str[255];
            intern self.max :=== 255;
        }
        
        operator[]<<(buf -> IOBuffer, val: str): IOBuffer {
            buf.buffer[] << val;
            if (buf.buffer.size() == max)
                buf.flush();
            return buf;
        }

        operator>>[](val: str, buf -> IOBuffer): IOBuffer {
            val >> buf.buffer[];
            if (buf.buffer.size() == max)
                buf.flush();
            return buf;
        }

        operator[](buf -> IOBuffer): IOBuffer {
            return buf.buffer[];
        }

        flush(): void {
            for (obj: str in buffer[])
                puts obj;
            buffer.clear();
        }

        size(): u8 {
            return buffer.size();
        }
    }

    safe buffer: IOBuffer;

    put(args: var, ...): void {
        for (obj: var in args[])
            buffer[] << (str) obj;
    }

    putln(args: var, ...): void {
        put(args);
        buffer[] << "\n";
        buffer.flush();
    }

    putf(data: str, args: var, ...): void {
        format(data, args);
        put(data);
    }

    getln(args: var, ...): str {
        put(args);
        flush();
        return __stdin(0, '\n');
    }

    getch(args: var, ...): c8 {
        put(args);
        buffer.flush();
        return __stdin(1);
    }

    clear(): void {
        buffer.flush();
        puts "\033[2J";
    }

    err(code: i64, args: var, ...): void {
        put(args);
        flush();
        if (code != 0)
            exit code;
    }
    
}