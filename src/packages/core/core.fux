&UNLOCK@VITAL // Unlocks vital data for this file
&VITAL@CPPFUX // Implements CPPFUX (parent class) 
&VITAL@OBJECT // Implements objects 

object CPPFUX:package instruction (package [&VAR_NAME][ = [&VAR_VALUE]];) -> &VAR@VITAL@PACKAGE;
// Defines package as a var type with instruction for declaration

object CPPFUX:int {
    instruction (int [&VAR_NAME][ = [&VAR_VALUE];]) -> &VAR@VITAL@INT

    object str:toString() {
        &VAR_NAME, "&VAR_VALUE" -> &VAR@VITAL@STR  // Creates variable new

        return &VAR;
    }
}

object CPPFUX:str {
    instruction (str [&VAR_NAME][ = [&VAR_VALUE];]) -> &VAR@VITAL@STR

    object int:toInteger() {
        &VAR_NAME, &VAR_VALUE -> &VAR@VITAL@INT
        except {
            error "\'\v\' can\'t be converted to integer\n", &VAR_VALUE;
            exit 1;
        }
        // if last statement didn't execute, it's the only possible error

        return &VAR;
    }

    object str:Replace(str old_string, str new_string, int count = 0) {
        if (count == 0) {
            for old_string in self {
                old_string, new_string -> &VITAL@REPL 
            }
        }
        else if (count > 0) {
            for i in range of count {
                old_string, new_string -> &VITAL@REPL
            }
        }
        else {
            error "Count (\v) can\'t be smaller than 0\n", count;
            exit 1;
        }
    }
}

object CPPFUX:bool {
    instruction (bool [&VAR_NAME][ = [&VAR_VALUE];]) -> &VAR@VITAL@BOOL

    object str:toString() {
        &VAR_NAME, "&VAR_VALUE" -> &VAR@VITAL@STR
        
        return &VAR;
    }

}

&VITAL@PACKAGE // defines the object/class underneath as a package
object Core {

    implement package;
    implement (int, str, bool);

    object Console {

        object 0:Output(str message, variables[]) {

            for var in variables {message = message.Replace("\v", var, 1);}
            message -> &VITAL@PRINT  

        }
    }

}
&LOCK@ALL