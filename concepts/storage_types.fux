binary_ -> binary = 011; // binary code; (0)11 = 3
int_ -> int; // 32-bit integer
real_ -> real; // 64-bit integer
float_ -> float; // 64-bit floating point integer
// or float(32bit) and double(64bit); but everyone would use double ...

char_ -> char // single-character
fixed_char -> char[5] = "fixed"; 
// single-character with fixed size (5 characters), can be changed (list of characters?)
// propably the same as char* in c(++)
fixed_char = "no"; // value can be smaller than fixed size
/*
This is invalid:
message -> char[] = "hello"; 
Why would you even? Use 'str'.
'char[N]' is just for saving memory.
*/

fixed_char_constant -> char[5] === "fixed"; // ..., constant -> can't be changed
str_ -> str; // string / list of characters

bool_ -> bool;// boolean; true/false

list_[] -> universal; // universal list with unfixed size 
list_[] << 0 << '1' << true;

position[2] -> float = [32435.325, 24213.241]; // list of floats with fixed size
//     size            [    x    ,     y    ];

universal_ -> universal; // variable that can hold values of any type
universal_ = 1;
universal_ = 'a';
universal_ = false;

// basic definition of an object in fux

object // what is it? an object. (optional)
myVar  // name
->     // points to type               (optional)
char   // type (char)                   "
[12]   // fixed size (12 characters)    "
===    // constant ('==='value... or '*'name...), normal would be '=' or without '*'
"Hello World!" // value, 12 characters
;      // semicolon; definitione ends here

// what could null look like in fux?
object null -> void === (void)0; // converting zero to void would be, like, nothing? nothing-er than void?
// or
typedef null (void)0;
// it's not an own type
typedef null 0;
// why would it exist then?
object null -> int === 0;
// ... but (null == 0) would be true ...